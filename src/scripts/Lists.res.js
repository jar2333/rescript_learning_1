// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Core__List = require("@rescript/core/src/Core__List.res.js");
var Core__Option = require("@rescript/core/src/Core__Option.res.js");

function test() {
  var fst_lst = {
    hd: 1,
    tl: {
      hd: 2,
      tl: {
        hd: 3,
        tl: /* [] */0
      }
    }
  };
  console.log(fst_lst);
  var fmap = function (lst, f) {
    if (lst) {
      return Core__List.add(fmap(lst.tl, f), f(lst.hd));
    } else {
      return /* [] */0;
    }
  };
  var snd_lst = fmap(fst_lst, (function (i) {
          return "a".repeat(i);
        }));
  console.log(snd_lst);
  var mergeSort = function (lst) {
    var size = Core__List.length(lst);
    var helper = function (lst, len) {
      if (!lst) {
        return lst;
      }
      if (!lst.tl) {
        return lst;
      }
      var mid_point = len / 2 | 0;
      var match = Core__Option.getOr(Core__List.splitAt(lst, mid_point), [
            lst,
            /* [] */0
          ]);
      var sorted_left = helper(match[0], mid_point);
      var sorted_right = helper(match[1], len - mid_point | 0);
      if (sorted_right) {
        if (sorted_left) {
          if (Caml_obj.lessequal(sorted_left.hd, sorted_right.hd)) {
            return Core__List.concat(sorted_left, sorted_right);
          } else {
            return Core__List.concat(sorted_right, sorted_left);
          }
        } else {
          return sorted_right;
        }
      } else {
        return sorted_left;
      }
    };
    return helper(lst, size);
  };
  console.log(mergeSort({
            hd: 3,
            tl: {
              hd: 6,
              tl: {
                hd: 7,
                tl: {
                  hd: 2,
                  tl: /* [] */0
                }
              }
            }
          }));
}

var name = "Lists";

exports.name = name;
exports.test = test;
/* No side effect */
